<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    
    <!-- === æ–°å¢ï¼šPWAå’ŒiPhoneå…¨å±æ˜¾ç¤ºæ”¯æŒ === -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Webå°è¯´é˜…è¯»å™¨">
    <link rel="apple-touch-icon" href="https://img.icons8.com/plasticine/100/000000/book.png">
    <!-- === æ–°å¢ç»“æŸ === -->

    <title>Web å°è¯´é˜…è¯»å™¨ (ç½‘ç»œä¿®å¤ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jschardet@3.0.0/dist/jschardet.min.js"></script>
    <style>
        :root {
            /* å¢åŠ  --content-padding å˜é‡ */
            --font-size: 20px; --line-height: 1.8; --content-padding: 20px; --main-bg-color: #f5f5dc;
            --main-text-color: #333; --panel-bg-color: rgba(255, 255, 255, 0.95);
            --panel-border-color: #ddd; --button-bg-color: #f0f0f0; --button-hover-bg-color: #e0e0e0;
            --link-color: #007bff; --overlay-color: rgba(245, 245, 220, 0.85); --highlight-color: #ffec3d;
            --active-item-bg: rgba(0, 123, 255, 0.1);
        }
        html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'Georgia', 'serif'; background-color: var(--main-bg-color); color: var(--main-text-color); background-size: cover; background-position: center; background-attachment: fixed; transition: background-color 0.3s, color 0.3s; }
        body.theme-light { --main-bg-color: #ffffff; --main-text-color: #000000; --panel-bg-color: rgba(248, 248, 248, 0.95); --overlay-color: rgba(255, 255, 255, 0.85); }
        body.theme-sepia { --main-bg-color: #f5eeda; --main-text-color: #5b4636; --panel-bg-color: rgba(243, 232, 214, 0.95); --overlay-color: rgba(245, 238, 218, 0.85); }
        body.theme-dark { --main-bg-color: #121212; --main-text-color: #e0e0e0; --panel-bg-color: rgba(45, 45, 45, 0.95); --panel-border-color: #555; --button-bg-color: #333; --button-hover-bg-color: #444; --overlay-color: rgba(18, 18, 18, 0.85); --highlight-color: #f9a825; --active-item-bg: rgba(255, 255, 255, 0.15); }
        body.theme-paper { --main-bg-color: #f5f5dc; --main-text-color: #3a3a3a; --panel-bg-color: rgba(245, 245, 220, 0.96); --overlay-color: rgba(245, 245, 220, 0.85); background-image: linear-gradient(rgba(220, 210, 190, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(220, 210, 190, 0.1) 1px, transparent 1px), linear-gradient(rgba(0,0,0,0.05) .5px, transparent .5px), radial-gradient(circle at center, #e6e2d9, #d1ccc1); background-size: 20px 20px, 20px 20px, 4px 4px, 100% 100%; }
        body.theme-green { --main-bg-color: #cce8cf; --main-text-color: #223e26; --panel-bg-color: rgba(225, 240, 227, 0.95); --overlay-color: rgba(204, 232, 207, 0.85); }
        body.theme-blue { --main-bg-color: #e0e8f0; --main-text-color: #2a3a4a; --panel-bg-color: rgba(224, 232, 240, 0.95); --overlay-color: rgba(224, 232, 240, 0.85); }
        body.theme-rose { --main-bg-color: #fbe9e7; --main-text-color: #5d4037; --panel-bg-color: rgba(251, 233, 231, 0.95); --overlay-color: rgba(251, 233, 231, 0.85); }
        body.theme-mint { --main-bg-color: #e0f2f1; --main-text-color: #004d40; --panel-bg-color: rgba(224, 242, 241, 0.95); --overlay-color: rgba(224, 242, 241, 0.85); }
        body.theme-lavender { --main-bg-color: #ede7f6; --main-text-color: #311b92; --panel-bg-color: rgba(237, 231, 246, 0.95); --overlay-color: rgba(237, 231, 246, 0.85); }
        body.theme-slate { --main-bg-color: #37474f; --main-text-color: #eceff1; --panel-bg-color: rgba(55, 71, 79, 0.95); --panel-border-color: #546e7a; --button-bg-color: #455a64; --button-hover-bg-color: #546e7a; --overlay-color: rgba(55, 71, 79, 0.85); --highlight-color: #80cbc4; }
        body.theme-solarized { --main-bg-color: #fdf6e3; --main-text-color: #073642; --panel-bg-color: rgba(253, 246, 227, 0.95); --overlay-color: rgba(253, 246, 227, 0.85); }
        body.theme-midnight { --main-bg-color: #000000; --main-text-color: #bdbdbd; --panel-bg-color: rgba(20, 20, 20, 0.95); --panel-border-color: #424242; --button-bg-color: #212121; --button-hover-bg-color: #424242; --overlay-color: rgba(0, 0, 0, 0.85); --highlight-color: #fdd835; }
        #content-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--overlay-color); z-index: -1; opacity: 0; transition: opacity 0.3s; }
        body.has-custom-bg #content-overlay { opacity: 1; }

        /* === ä¿®æ”¹é‡ç‚¹ï¼šå½»åº•ä¿®å¤é®æŒ¡é—®é¢˜çš„æ ¸å¿ƒå¸ƒå±€ === */
        #reader-container {
            position: fixed;
            top: 70px; /* ä¸ºé¡¶éƒ¨å›¾æ ‡ç•™å‡ºç©ºé—´ */
            bottom: 60px; /* ä¸ºåº•éƒ¨å·¥å…·æ ç•™å‡ºç©ºé—´ */
            left: 0;
            right: 0;
            font-size: var(--font-size);
            line-height: var(--line-height);
            text-align: justify;
        }
        
        /* === æ–°å¢ï¼šå·¦å³ç¿»é¡µæ¨¡å¼ä¸‹ï¼Œå¢åŠ ä¸Šä¸‹å®‰å…¨è·ç¦»ï¼Œé˜²æ­¢é®æŒ¡ === */
        body.paginate-mode #reader-container {
            top: 70px;   /* é¡¶éƒ¨ä¸‹ç§»ï¼Œé¿å¼€ä¹¦ç­¾/æœç´¢æŒ‰é’® */
            bottom: 90px; /* åº•éƒ¨ä¸Šç§»ï¼Œé¿å¼€ä¸Šä¸€é¡µ/ä¸‹ä¸€é¡µæŒ‰é’® */
        }
        /* === æ–°å¢ç»“æŸ === */

        /* === ä¿®æ”¹ç»“æŸ === */
        
        /* === ä¿®æ”¹ï¼šä¿®å¤å·¦å³è¾¹è·ä¸å¯¹ç§° === */
        /* width: 100% é…åˆ border-boxï¼Œè®© padding å‘å†…æŒ¤å‹ï¼Œä¿è¯å·¦å³ç»å¯¹å¯¹ç§° */
        #txt-content-wrapper, #epub-content { 
            width: 100%; 
            height: 100%; 
            padding: 0 var(--content-padding); 
            margin: 0 auto; 
            box-sizing: border-box; 
        }
        #epub-content { position: absolute; top: 0; padding: 0; }
        /* === ä¿®æ”¹ç»“æŸ === */
        body.scroll-mode #txt-content-wrapper { overflow-y: auto; -webkit-overflow-scrolling: touch; padding-bottom: 50vh; }
        body.scroll-mode .pagination-controls { display: none; }
        body.paginate-mode #txt-content-wrapper { overflow: hidden; }
        
        /* === ä¿®æ”¹ï¼šç»™åº•éƒ¨å¢åŠ  20px çš„é˜²åˆ‡å‰²å®‰å…¨åŒº === */
        body.paginate-mode #txt-content { 
            height: 100%; 
            box-sizing: border-box; /* ç¡®ä¿å†…è¾¹è·ç®—åœ¨é«˜åº¦å†… */
            padding-bottom: 20px;   /* å…³é”®ï¼šåº•éƒ¨ç•™ç™½ï¼Œé˜²æ­¢æœ€åä¸€è¡Œè¢«åˆ‡ */
        }
        /* === ä¿®æ”¹ç»“æŸ === */

        body.paginate-mode .pagination-controls { display: flex; }
        .pagination-controls { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; justify-content: space-between; align-items: center; pointer-events: none; z-index: 20; }
        .pagination-controls > div { width: 25%; height: 100%; cursor: pointer; pointer-events: auto; }
        .panel { position: fixed; top: 0; width: 320px; height: 100%; background-color: var(--panel-bg-color); box-shadow: 0 0 15px rgba(0, 0, 0, 0.2); padding: 20px; box-sizing: border-box; z-index: 1000; transition: transform 0.3s ease-in-out; overflow-y: auto; }
        .panel-toggle { position: fixed; top: 20px; width: 40px; height: 40px; background-color: var(--panel-bg-color); border: 1px solid var(--panel-border-color); border-radius: 50%; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 24px; z-index: 1001; box-shadow: 0 2px 5px rgba(0,0,0,0.1); user-select: none; }
        #settings-toggle { right: 20px; } #settings-panel { right: 0; transform: translateX(100%); } #settings-panel.open { transform: translateX(0); }
        #toc-toggle { left: 20px; } #toc-panel { left: 0; transform: translateX(-100%); } #toc-panel.open { transform: translateX(0); }
        #library-toggle { left: 70px; } #library-panel { left: 0; transform: translateX(-100%); } #library-panel.open { transform: translateX(0); }
        #bookmarks-toggle { left: 120px; } #bookmarks-panel { left: 0; transform: translateX(-100%); } #bookmarks-panel.open { transform: translateX(0); }
        /* === ä¿®æ”¹ï¼šæœç´¢æŒ‰é’®ç§»åˆ°é¡¶éƒ¨ï¼Œä½äºè®¾ç½®æŒ‰é’®å·¦ä¾§ === */
        #search-toggle { right: 70px; font-size: 20px; }
        /* === ä¿®æ”¹ç»“æŸ === */
        .settings-group { margin-bottom: 25px; border-bottom: 1px solid var(--panel-border-color); padding-bottom: 15px; }
        /* === ä¿®æ”¹ï¼šå¢åŠ  gap å±æ€§ï¼Œè®©æŒ‰é’®ä¸Šä¸‹å·¦å³éƒ½æœ‰é—´è· === */
        .control-row, .button-group { display: flex; align-items: center; margin-bottom: 10px; gap: 10px; flex-wrap: wrap; }
        /* === ä¿®æ”¹ç»“æŸ === */
        .control-row label { margin-right: 10px; }
        .control-row input, .control-row select { flex-grow: 1; margin-right: 10px; padding: 8px; border: 1px solid var(--panel-border-color); background-color: var(--main-bg-color); color: var(--main-text-color); border-radius: 4px; }
        .control-row button, .button-group button, .file-label { padding: 8px 12px; border: 1px solid var(--panel-border-color); background-color: var(--button-bg-color); color: var(--main-text-color); cursor: pointer; border-radius: 4px; transition: background-color 0.2s; white-space: nowrap; }
        .button-group button.active { background-color: var(--link-color); color: white; border-color: var(--link-color); }
        input[type="file"] { display: none; } .file-label { display: block; text-align: center; width: 100%; box-sizing: border-box; }
        .book-item, .bookmark-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid var(--panel-border-color); }
        .book-item:last-child, .bookmark-item:last-child { border-bottom: none; }
        .book-item-info { flex-grow: 1; cursor: pointer; }
        .book-item-actions button { margin-left: 5px; font-size: 14px; padding: 2px 6px; }
        .bookmark-item a { flex-grow: 1; text-decoration: none; color: var(--main-text-color); display: block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        /* === æ–°å¢ï¼šå‡€åŒ–è§„åˆ™åˆ—è¡¨æ ·å¼ === */
        .replace-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid var(--panel-border-color); font-size: 14px; }
        .replace-item span { flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; margin-right: 10px; color: #d32f2f; }
        /* === æ–°å¢ç»“æŸ === */

        #toc-list li.active-toc-item > a { color: var(--link-color); font-weight: bold; }
        #toc-list li.active-toc-item { background-color: var(--active-item-bg); }
        #bottom-bar { position: fixed; bottom: 0; left: 0; width: 100%; height: 60px; background-color: var(--panel-bg-color); border-top: 1px solid var(--panel-border-color); box-shadow: 0 -2px 10px rgba(0,0,0,0.1); z-index: 999; display: flex; align-items: center; padding: 0 20px; box-sizing: border-box; }
        #bottom-bar button { padding: 8px 15px; margin: 0 5px; }
        #progress-container { flex-grow: 1; display: flex; align-items: center; margin: 0 10px; }
        #progress-slider { width: 100%; -webkit-appearance: none; appearance: none; height: 5px; background: var(--panel-border-color); outline: none; border-radius: 5px; }
        #progress-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 15px; height: 15px; background: var(--link-color); border-radius: 50%; cursor: pointer; }
        #progress-percent { min-width: 50px; text-align: right; font-size: 14px; }
        #search-bar { position: fixed; bottom: -100px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 500px; background-color: var(--panel-bg-color); border: 1px solid var(--panel-border-color); border-radius: 8px 8px 0 0; padding: 10px; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); z-index: 1002; display: flex; align-items: center; transition: bottom 0.3s ease-in-out; }
        #search-bar.open { bottom: 0; }
        #loading-indicator, #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); z-index: 2000; display: none; justify-content: center; align-items: center; }
        #loading-indicator span { color: white; padding: 15px 30px; border-radius: 8px; background-color: rgba(0,0,0,0.8); }
        #edit-book-modal { background-color: var(--panel-bg-color); padding: 25px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); width: 90%; max-width: 400px; }
        #edit-book-modal h3 { margin-top: 0; }
        #edit-book-modal input { width: calc(100% - 16px); padding: 8px; margin-bottom: 15px; }
        #welcome-message { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center; font-size: 1.2em; color: #888; }
        mark { background-color: var(--highlight-color); color: black; }
        .chapter-title { display: block; font-weight: bold; margin-top: 1.5em; margin-bottom: 1em; }
                /* === æ–°å¢ï¼šTXT 3D ç¿»é¡µåŠ¨ç”»æ•ˆæœ === */
        #txt-content-wrapper {
            perspective: 2000px; /* å¢åŠ  3D è§†è·ï¼Œæ•°å€¼è¶Šå¤§é€è§†è¶Šå° */
            overflow: hidden;    /* ç¡®ä¿ç¿»é¡µæ—¶ä¸å‡ºç°æ»šåŠ¨æ¡ */
        }
        
        #txt-content {
            transform-style: preserve-3d; /* å¼€å¯ 3D ç©ºé—´ */
            backface-visibility: hidden;  /* èƒŒé¢ä¸å¯è§ */
            transform-origin: left center; /* é»˜è®¤å·¦ä¾§ä¸ºè½´ */
        }

        /* å‘ä¸‹ç¿»é¡µï¼ˆç¿»å¼€ä¸‹ä¸€é¡µï¼‰ï¼šæ—§é¡µå‘å·¦ç¿»èµ°ï¼Œæ–°é¡µä»å³ç¿»å…¥ */
        .anim-next-out { animation: flipNextOut 0.4s ease-in forwards; }
        .anim-next-in  { animation: flipNextIn 0.4s ease-out forwards; }

        /* å‘ä¸Šç¿»é¡µï¼ˆç¿»å›ä¸Šä¸€é¡µï¼‰ï¼šæ—§é¡µå‘å³ç¿»èµ°ï¼Œæ–°é¡µä»å·¦ç¿»å…¥ */
        .anim-prev-out { animation: flipPrevOut 0.4s ease-in forwards; }
        .anim-prev-in  { animation: flipPrevIn 0.4s ease-out forwards; }

        @keyframes flipNextOut {
            0% { transform: rotateY(0deg); opacity: 1; }
            100% { transform: rotateY(-90deg); opacity: 0.5; }
        }
        @keyframes flipNextIn {
            0% { transform: rotateY(90deg); opacity: 0.5; }
            100% { transform: rotateY(0deg); opacity: 1; }
        }

        @keyframes flipPrevOut {
            0% { transform: rotateY(0deg); opacity: 1; }
            100% { transform: rotateY(90deg); opacity: 0.5; }
        }
        @keyframes flipPrevIn {
            0% { transform: rotateY(-90deg); opacity: 0.5; }
            100% { transform: rotateY(0deg); opacity: 1; }
        }
        /* === æ–°å¢ç»“æŸ === */

    </style>
</head>
<body>
    <div id="content-overlay"></div>
    <div id="reader-container">
        <div id="txt-content-wrapper"><div id="txt-content"><div id="welcome-message"><h1>Web å°è¯´é˜…è¯»å™¨</h1><p>ç‚¹å‡»å·¦ä¸Šè§’ ğŸ“š ä¹¦åº“å›¾æ ‡å¼€å§‹é˜…è¯»</p></div></div></div>
        <div id="epub-content"></div>
        <div class="pagination-controls"><div id="prev-page"></div><div id="next-page"></div></div>
    </div>

    <div id="bottom-bar">
        <button id="prev-chapter-btn">ä¸Šä¸€ç« </button>
        <button id="prev-page-btn" data-action="prev" style="display:none;">ä¸Šä¸€é¡µ</button>
        <div id="progress-container"><input type="range" min="0" max="100" value="0" id="progress-slider"><span id="progress-percent">0%</span></div>
        <button id="next-page-btn" data-action="next" style="display:none;">ä¸‹ä¸€é¡µ</button>
        <button id="next-chapter-btn">ä¸‹ä¸€ç« </button>
    </div>

    <!-- Panels and other HTML are unchanged -->
    <div id="toc-toggle" class="panel-toggle">ğŸ“–</div><div id="toc-panel" class="panel"><h3>ç›®å½•</h3><ul id="toc-list"></ul></div>
    <div id="library-toggle" class="panel-toggle">ğŸ“š</div><div id="library-panel" class="panel"><h3>æˆ‘çš„ä¹¦åº“</h3><ul id="library-list"></ul></div>
    <div id="bookmarks-toggle" class="panel-toggle">ğŸ”–</div>
    <div id="bookmarks-panel" class="panel">
        <h3>ä¹¦ç­¾</h3>
        <button id="add-bookmark-btn" style="width: 100%; margin-bottom: 15px;">æ·»åŠ å½“å‰ä½ç½®ä¸ºä¹¦ç­¾</button>
        <ul id="bookmarks-list"></ul>
    </div>
    <div id="settings-toggle" class="panel-toggle">âš™ï¸</div>
    <div id="settings-panel" class="panel">
        <div class="settings-group">
            <h3>å¯¼å…¥å°è¯´</h3>
            <div class="control-row"><input type="text" id="url-input" placeholder="è¾“å…¥ç½‘ç»œTXT/EPUBæ–‡ä»¶é“¾æ¥"><button id="load-url-btn">åŠ è½½</button></div>
            <div class="control-row"><input type="file" id="file-input" accept=".txt,.epub"><label for="file-input" class="file-label">ä»æœ¬åœ°å¯¼å…¥</label></div>
            <div class="control-row">
                <label for="encoding-select">TXTç¼–ç :</label>
                <select id="encoding-select">
                    <option value="auto">è‡ªåŠ¨æ£€æµ‹</option>
                    <option value="UTF-8">UTF-8</option>
                    <option value="GBK">GBK</option>
                    <option value="Big5">Big5 (ç¹ä½“)</option>
                </select>
            </div>
        </div>
        <div class="settings-group">
            <h3>æ˜¾ç¤ºè®¾ç½®</h3>
            <div class="control-row"><select id="font-select"></select></div>
            <div class="control-row"><button id="decrease-font-btn">-</button><span id="font-size-display">20px</span><button id="increase-font-btn">+</button></div>
            <!-- æ–°å¢è¡Œè·å’Œè¾¹è·æ§åˆ¶ -->
            <div class="control-row"><label>è¡Œè·:</label><input type="range" id="line-height-input" min="1.0" max="3.0" step="0.1" value="1.8"><span id="line-height-val">1.8</span></div>
            <div class="control-row"><label>è¾¹è·:</label><input type="range" id="padding-input" min="0" max="100" step="5" value="20"><span id="padding-val">20</span></div>
        </div>
        <div class="settings-group"><h3>è‡ªå®šä¹‰å­—ä½“</h3><div class="control-row"><input type="text" id="custom-font-name" placeholder="å­—ä½“åç§°"><input type="text" id="custom-font-url" placeholder="å­—ä½“æ–‡ä»¶é“¾æ¥"></div><div class="control-row"><button id="add-font-btn" style="width:50%; margin-right:5px;">æ·»åŠ é“¾æ¥å­—ä½“</button><input type="file" id="font-file-input" accept=".ttf,.otf,.woff,.woff2"><label for="font-file-input" class="file-label" style="width:50%;">æœ¬åœ°å­—ä½“</label></div></div>
        <!-- === ä¿®æ”¹ï¼šåˆ é™¤äº†ä¸éœ€è¦çš„ä¸»é¢˜ï¼Œå»æ‰äº† style === -->
        <div class="settings-group">
            <h3>èƒŒæ™¯ä¸»é¢˜</h3>
            <div class="button-group" id="theme-buttons">
                <button data-theme="light">æ—¥é—´</button>
                <button data-theme="sepia">æŠ¤çœ¼</button>
                <button data-theme="green">ç»¿æ„</button>
                <button data-theme="blue">å•†åŠ¡</button>
                <button data-theme="rose">ç«ç‘°</button>
                <button data-theme="mint">è–„è·</button>
                <button data-theme="lavender">è–°è¡£</button>
                <button data-theme="slate">çŸ³æ¿</button>
            </div>
        </div>
        <!-- === ä¿®æ”¹ç»“æŸ === -->
        <div class="settings-group"><h3>è‡ªå®šä¹‰èƒŒæ™¯</h3><div class="control-row"><select id="bg-select"></select><button id="delete-bg-btn" style="min-width: 40px;">ğŸ—‘ï¸</button></div><div class="control-row"><input type="text" id="bg-url-input" placeholder="è¾“å…¥å›¾ç‰‡é“¾æ¥"><button id="add-bg-url-btn">æ·»åŠ </button></div><div class="control-row"><input type="file" id="bg-file-input" accept="image/*"><label for="bg-file-input" class="file-label">æ·»åŠ æœ¬åœ°å›¾ç‰‡</label></div></div>
        
        <!-- === æ–°å¢ï¼šå†…å®¹å‡€åŒ–é¢æ¿ === -->
        <div class="settings-group">
            <h3>å†…å®¹å‡€åŒ– (è‡ªåŠ¨åˆ é™¤)</h3>
            <div class="control-row">
                <input type="text" id="replace-input" placeholder="è¾“å…¥è¦å»é™¤çš„æ–‡å­—æˆ–å¹¿å‘Š">
                <button id="add-replace-btn">æ·»åŠ è§„åˆ™</button>
            </div>
            <ul id="replace-list" style="list-style: none; padding: 0; margin: 0;"></ul>
            <div style="font-size: 12px; color: #888; margin-top: 5px;">* ä¿®æ”¹åéœ€é‡æ–°åŠ è½½ä¹¦ç±ç”Ÿæ•ˆ</div>
        </div>
        <!-- === æ–°å¢ç»“æŸ === -->

        <div class="settings-group"><h3>ç¿»é¡µæ¨¡å¼</h3><div class="button-group" id="layout-buttons"><button data-layout="scroll">ä¸Šä¸‹æ»šåŠ¨</button><button data-layout="paginate">å·¦å³ç¿»é¡µ</button></div></div>
    </div>
    <div id="search-toggle" class="panel-toggle">ğŸ”</div><div id="search-bar"><input type="text" id="search-input" placeholder="æœç´¢..."><button id="search-prev-btn">â†‘</button><button id="search-next-btn">â†“</button><span id="search-results-count">0 / 0</span></div>
    <div id="loading-indicator"><span>åŠ è½½ä¸­...</span></div>
    <div id="modal-overlay">
        <div id="edit-book-modal">
            <h3>ç¼–è¾‘ä¹¦ç±ä¿¡æ¯</h3>
            <input type="hidden" id="edit-book-url">
            <label for="edit-book-name">ä¹¦å:</label>
            <input type="text" id="edit-book-name">
            <label for="edit-book-category">åˆ†ç±»:</label>
            <input type="text" id="edit-book-category">
            <div style="text-align: right;">
                <button id="cancel-edit-book-btn">å–æ¶ˆ</button>
                <button id="save-edit-book-btn">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const preloadedBooks = [ { name: "åœ¨çº¿ä¹¦ç±ç¤ºä¾‹", url: "https://files.catbox.moe/y91f7r.txt", category: "æˆ‘çš„ä¹¦æ¶" } ];
        // === ä¿®æ”¹ï¼šå¢åŠ  replacements æ•°ç»„ç”¨äºå­˜å‚¨å‡€åŒ–è§„åˆ™ ===
        const settings = { fontFamily: "'-apple-system', 'sans-serif'", fontSize: 20, lineHeight: 1.8, contentPadding: 20, theme: 'light', layout: 'scroll', customFonts: [], customBgs: [], replacements: [], books: {}, readingProgress: {}, bookmarks: {} };
        // === ä¿®æ”¹ç»“æŸ ===
        // === ä¿®æ”¹ç»“æŸ ===
        
        const $ = (s) => document.querySelector(s); const $$ = (s) => document.querySelectorAll(s);
        const body = document.body; const readerContainer = $('#reader-container'); const txtContentWrapper = $('#txt-content-wrapper'); const txtContent = $('#txt-content'); const epubContent = $('#epub-content'); const progressSlider = $('#progress-slider'); const progressPercent = $('#progress-percent'); const fontSelect = $('#font-select'); const bgSelect = $('#bg-select');

        let book = null, rendition = null, currentBookType = null, currentLocation = null, currentBookUrl = null, saveInterval = null;
        let currentTxtFileBuffer = null;
        let currentEpubChapterIndex = -1;
        let txtChapterAnchors = [], searcher = { results: [], currentIndex: -1, originalTxtContent: '' };
        let txtPages = [];
        let currentTxtPageIndex = 0;
        let isPaginating = false;
        let fullTxtHtml = '';
        
        // === æ–°å¢ï¼šIndexedDB æ•°æ®åº“å¸®åŠ©å‡½æ•° ===
        let db;
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open("novelReaderDB", 1);
                request.onerror = (event) => reject("æ•°æ®åº“æ‰“å¼€æŠ¥é”™");
                request.onsuccess = (event) => {
                    db = event.target.result;
                    resolve(db);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('localBooks')) {
                        db.createObjectStore('localBooks', { keyPath: 'url' });
                    }
                    // === æ–°å¢ï¼šåˆ›å»ºå­—ä½“å­˜å‚¨è¡¨ ===
                    if (!db.objectStoreNames.contains('localFonts')) {
                        db.createObjectStore('localFonts', { keyPath: 'name' });
                    }
                    // === æ–°å¢ç»“æŸ ===
                };
            });
        }

        function saveBookToDB(bookData) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['localBooks'], 'readwrite');
                const store = transaction.objectStore('localBooks');
                const request = store.put(bookData);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject('ä¿å­˜ä¹¦ç±åˆ°æ•°æ®åº“å¤±è´¥:', event.target.error);
            });
        }

        function getBookFromDB(url) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['localBooks'], 'readonly');
                const store = transaction.objectStore('localBooks');
                const request = store.get(url);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject('ä»æ•°æ®åº“è¯»å–ä¹¦ç±å¤±è´¥:', event.target.error);
            });
        }

        function deleteBookFromDB(url) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['localBooks'], 'readwrite');
                const store = transaction.objectStore('localBooks');
                const request = store.delete(url);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject('ä»æ•°æ®åº“åˆ é™¤ä¹¦ç±å¤±è´¥:', event.target.error);
            });
        }

        // === æ–°å¢ï¼šå­—ä½“æ•°æ®åº“æ“ä½œå‡½æ•° ===
        function saveFontToDB(fontData) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['localFonts'], 'readwrite');
                const store = transaction.objectStore('localFonts');
                const request = store.put(fontData);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject('ä¿å­˜å­—ä½“å¤±è´¥:', event.target.error);
            });
        }

        function getAllFontsFromDB() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['localFonts'], 'readonly');
                const store = transaction.objectStore('localFonts');
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject('è¯»å–å­—ä½“å¤±è´¥:', event.target.error);
            });
        }
        // === æ–°å¢ç»“æŸ ===

        // === æ–°å¢ç»“æŸ === (æ³¨æ„ï¼šè¿™é‡Œä¿ç•™åŸæœ‰çš„æ³¨é‡Šé—­åˆï¼Œæˆ–è€…ç›´æ¥æ¥ä¸‹é¢çš„ä»£ç )

        const proxyList = [ 'https://api.allorigins.win/raw?url=', 'https://cors.eu.org/' ];
        async function fetchWithProxy(url, options = { timeout: 15000 }) { for (let i = 0; i < proxyList.length; i++) { const proxyUrl = `${proxyList[i]}${encodeURIComponent(url)}`; try { const response = await fetchWithTimeout(proxyUrl, options); if (!response.ok) throw new Error(`ä»£ç†æœåŠ¡å™¨å“åº”çŠ¶æ€: ${response.status}`); return response; } catch (error) { console.error(`ä»£ç† ${proxyList[i]} å¤±è´¥.`, error.name === 'AbortError' ? 'è¯·æ±‚è¶…æ—¶.' : error.message); } } throw new Error('æ‰€æœ‰å†…å®¹ä»£ç†å‡å¤±è´¥ã€‚æœåŠ¡å¯èƒ½æš‚æ—¶ä¸å¯ç”¨ï¼Œæˆ–é“¾æ¥æ— æ•ˆã€‚'); }
        async function fetchWithTimeout(resource, options = {}) { const { timeout = 8000 } = options; const controller = new AbortController(); const id = setTimeout(() => controller.abort(), timeout); const response = await fetch(resource, { ...options, signal: controller.signal }); clearTimeout(id); return response; }
        const showLoading = (show, text = "åŠ è½½ä¸­...") => { const indicator = $('#loading-indicator'); indicator.querySelector('span').textContent = text; indicator.style.display = show ? 'flex' : 'none'; }
        
        async function loadBook(url, name, category) {
            showLoading(true, "æ­£åœ¨è·å–ä¹¦ç±...");
            setTimeout(async () => {
                try {
                    let arrayBuffer;
                    if (url.startsWith('local-')) {
                        const bookData = await getBookFromDB(url);
                        if (bookData) {
                            arrayBuffer = bookData.content;
                        } else {
                            throw new Error('æœ¬åœ°ä¹¦ç±æœªåœ¨æ•°æ®åº“ä¸­æ‰¾åˆ°ã€‚');
                        }
                    } else {
                        const response = url.startsWith('http') ? await fetchWithProxy(url) : await fetch(url);
                        arrayBuffer = await response.arrayBuffer();
                    }

                    cleanupPreviousBook();
                    currentBookUrl = url;
                    const isEpub = name.endsWith('.epub') || url.endsWith('.epub');

                    if (isEpub) { 
                        await processEpubContent(arrayBuffer); 
                    } else { 
                        currentTxtFileBuffer = arrayBuffer;
                        await processTxtContent();
                    }
                    if (name) addBookToLibrary(name, url, category);
                    renderBookmarks();
                    startProgressSaving();
                } catch (error) {
                    console.error("åŠ è½½ä¹¦ç±å¤±è´¥:", error);
                    alert(`åŠ è½½ä¹¦ç±å¤±è´¥ã€‚\n\nåŸå› : ${error.message}`);
                } finally {
                    showLoading(false);
                }
            }, 50);
        }

        async function performSearch(query) { if (!query) { clearSearch(); return; } showLoading(true, "æ­£åœ¨å…¨æ–‡æœç´¢..."); setTimeout(async () => { try { searcher.results = []; if (currentBookType === 'txt') { const regex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'); let match; while ((match = regex.exec(searcher.originalTxtContent)) !== null) { searcher.results.push(match.index); } highlightTxtSearch(query); } else if (book) { const spineResults = await Promise.all( book.spine.items.map(item => item.load(book.load.bind(book)).then(doc => item.find(query)).finally(() => item.unload())) ); searcher.results = [].concat.apply([], spineResults); rendition.annotations.remove(query, "highlight"); searcher.results.forEach(res => { rendition.annotations.highlight(res.cfi, {}, null, "hl", { "fill": "yellow", "fill-opacity": "0.3" }); }); } searcher.currentIndex = searcher.results.length > 0 ? 0 : -1; navigateToMatch(0); } catch (error) { console.error("æœç´¢å¤±è´¥:", error); alert("æœç´¢æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯ã€‚"); } finally { updateSearchUI(); showLoading(false); } }, 50); }
        const saveSettings = () => localStorage.setItem('readerSettings', JSON.stringify(settings));
        function loadSettings() { 
            const saved = localStorage.getItem('readerSettings'); 
            if (saved) { Object.assign(settings, JSON.parse(saved)); } 
            
            // ç¡®ä¿ replacements æ•°ç»„å­˜åœ¨
            ['books', 'readingProgress', 'bookmarks', 'customFonts', 'customBgs', 'replacements'].forEach(key => { 
                if (!settings[key]) settings[key] = Array.isArray(settings[key]) ? [] : {}; 
            }); 

            if (preloadedBooks.length > 0 && Object.keys(settings.books).every(cat => settings.books[cat].length === 0)) { 
                preloadedBooks.forEach(book => { 
                    const category = book.category || 'æœªåˆ†ç±»'; 
                    if (!settings.books[category]) settings.books[category] = []; 
                    if (!settings.books[category].some(b => b.url === book.url)) { 
                        settings.books[category].push({ name: book.name, url: book.url }); 
                    } 
                }); 
                saveSettings(); 
            } 
            
            populateFontSelect(); 
            populateBgSelect(); 
            renderLibrary(); 
            applyAllSettings();
            
            // === æ–°å¢ï¼šæ¸²æŸ“å‡€åŒ–è§„åˆ™åˆ—è¡¨ ===
            renderReplacements();
            // === æ–°å¢ç»“æŸ ===
        }

        // === æ–°å¢ï¼šå‡€åŒ–è§„åˆ™ç›¸å…³å‡½æ•° ===
        function renderReplacements() {
            const list = $('#replace-list');
            list.innerHTML = '';
            settings.replacements.forEach((rule, index) => {
                list.innerHTML += `
                    <li class="replace-item">
                        <span>${rule}</span>
                        <button onclick="deleteReplacement(${index})" style="padding: 2px 6px;">âœ–</button>
                    </li>`;
            });
        }

        window.deleteReplacement = (index) => {
            settings.replacements.splice(index, 1);
            saveSettings();
            renderReplacements();
        };

        $('#add-replace-btn').addEventListener('click', () => {
            const input = $('#replace-input');
            const val = input.value.trim();
            if (val && !settings.replacements.includes(val)) {
                settings.replacements.push(val);
                saveSettings();
                renderReplacements();
                input.value = '';
                alert('è§„åˆ™å·²æ·»åŠ ã€‚è¯·é‡æ–°æ‰“å¼€ä¹¦ç±æˆ–åˆ·æ–°é¡µé¢ä»¥åº”ç”¨å‡€åŒ–ã€‚');
            }
        });
        // === æ–°å¢ç»“æŸ ===
        function applyFontSettings() { 
            const oldFontSize = settings.fontSize; 
            
            // åº”ç”¨å­—ä½“å¤§å°
            document.documentElement.style.setProperty('--font-size', `${settings.fontSize}px`); 
            
            // === æ–°å¢ï¼šåº”ç”¨è¡Œè·å’Œè¾¹è· ===
            document.documentElement.style.setProperty('--line-height', settings.lineHeight);
            document.documentElement.style.setProperty('--content-padding', `${settings.contentPadding}px`);
            
            // æ›´æ–°ç•Œé¢æ˜¾ç¤ºæ•°å€¼
            $('#line-height-input').value = settings.lineHeight;
            $('#line-height-val').textContent = settings.lineHeight;
            $('#padding-input').value = settings.contentPadding;
            $('#padding-val').textContent = settings.contentPadding;
            // === æ–°å¢ç»“æŸ ===

            readerContainer.style.fontFamily = settings.fontFamily; 
            
            if (rendition) { 
                rendition.themes.fontSize(`${settings.fontSize}px`); 
                rendition.themes.font(settings.fontFamily); 
                // Epub.js å¯èƒ½éœ€è¦å•ç‹¬è®¾ç½®è¡Œè·ï¼Œä½†é€šå¸¸ç»§æ‰¿ CSS
            } 
            
            $('#font-size-display').textContent = `${settings.fontSize}px`; 
            $('#font-select').value = settings.fontFamily; 
            
            if (oldFontSize !== settings.fontSize && currentBookType === 'txt' && settings.layout === 'paginate') { 
                paginateAndDisplayTxt(); 
            } 
        }
        
        function applyAllSettings() {
            applyFontSettings();
            body.className = ''; body.classList.add(`theme-${settings.theme}`);
            const activeBg = settings.customBgs.find(b => b.active); applyBackgroundImage(activeBg ? activeBg.url : '');
            body.classList.add(`${settings.layout}-mode`);
            if (currentBookType === 'epub') { epubContent.style.display = 'block'; txtContentWrapper.style.display = 'none'; } else { epubContent.style.display = 'none'; txtContentWrapper.style.display = 'block'; }
            $$('#theme-buttons button').forEach(b => b.classList.toggle('active', b.dataset.theme === settings.theme));
            $('#bg-select').value = activeBg ? activeBg.name : 'default';
            $$('#layout-buttons button').forEach(b => b.classList.toggle('active', b.dataset.layout === settings.layout));
            const isPaginateMode = settings.layout === 'paginate';
            $('#prev-page-btn').style.display = isPaginateMode ? 'inline-block' : 'none';
            $('#next-page-btn').style.display = isPaginateMode ? 'inline-block' : 'none';
        }
        
        function cleanupPreviousBook() { if (saveInterval) { clearInterval(saveInterval); saveInterval = null; } txtContent.innerHTML = ''; epubContent.innerHTML = ''; $('#toc-list').innerHTML = ''; txtChapterAnchors = []; searcher = { results: [], currentIndex: -1, originalTxtContent: '' }; updateSearchUI(); if (rendition) { rendition.destroy(); book = null; rendition = null; } currentBookUrl = null; currentEpubChapterIndex = -1; currentTxtFileBuffer = null; txtPages = []; currentTxtPageIndex = 0; fullTxtHtml = ''; updateProgress(0); }
        async function processTxtContent() { if (!currentTxtFileBuffer) return; currentBookType = 'txt'; applyAllSettings(); let text; const selectedEncoding = $('#encoding-select').value; try { const detection = jschardet.detect(new Uint8Array(currentTxtFileBuffer)); const finalEncoding = selectedEncoding === 'auto' ? (detection.encoding ? detection.encoding.toLowerCase() : 'utf-8') : selectedEncoding; text = new TextDecoder(finalEncoding.includes('gb') ? 'gbk' : finalEncoding).decode(currentTxtFileBuffer); } catch(e) { text = `æ–‡ä»¶è§£ç å¤±è´¥ã€‚è¯·å°è¯•æ‰‹åŠ¨é€‰æ‹©å…¶ä»–ç¼–ç æ ¼å¼ã€‚`; txtContent.innerHTML = `<p>${text}</p>`; return; } $('#welcome-message')?.remove(); generateTxtTocAndContent(text); if (settings.layout === 'paginate') { await paginateAndDisplayTxt(); } else { txtContent.innerHTML = fullTxtHtml; txtContentWrapper.scrollTo(0, 0); } loadLastPosition(); }
                // === ä¿®æ”¹ï¼šä¿®å¤â€œæ¯é¡µåªæ˜¾ç¤ºä¸€æ®µâ€çš„ Bug ===
        async function paginateAndDisplayTxt() {
            if (isPaginating || !fullTxtHtml) return;
            isPaginating = true;
            showLoading(true, "æ­£åœ¨é‡æ–°æ’ç‰ˆ...");
            await new Promise(resolve => setTimeout(resolve, 50));

            const container = txtContentWrapper;
            const content = txtContent;
            
            // 1. ä¸´æ—¶ç§»é™¤ CSS é™åˆ¶ï¼Œç¡®ä¿ scrollHeight èƒ½å¤Ÿååº”çœŸå®æ–‡å­—é«˜åº¦
            const originalHeight = content.style.height;
            const originalPadding = content.style.paddingBottom;
            content.style.height = 'auto'; 
            content.style.paddingBottom = '0px'; 
            
            // è®¡ç®—å¯ç”¨é«˜åº¦ï¼ˆå®¹å™¨é«˜åº¦ - ä¸Šä¸‹å†…è¾¹è·ï¼‰
            // æ³¨æ„ï¼šè¿™é‡Œè¦è·å– container çš„é«˜åº¦ï¼Œé¢„ç•™åº•éƒ¨å®‰å…¨è·ç¦»
            const containerStyle = window.getComputedStyle(container);
            // å‡å» 30px æ˜¯ä¸ºäº†ä¿é™©ï¼Œç»™åº•éƒ¨ç•™å‡ºè¶³å¤Ÿçš„é˜²åˆ‡å‰²ç©ºé—´
            const availableHeight = container.clientHeight - parseFloat(containerStyle.paddingTop) - parseFloat(containerStyle.paddingBottom) - 30;
            
            txtPages = [];
            content.innerHTML = '';
            
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = fullTxtHtml;
            const nodes = Array.from(tempDiv.children);

            let currentPageNodes = [];

            const savePage = () => {
                content.innerHTML = '';
                currentPageNodes.forEach(n => content.appendChild(n));
                txtPages.push(content.innerHTML);
                content.innerHTML = '';
                currentPageNodes = [];
            };

            for (let i = 0; i < nodes.length; i++) {
                let node = nodes[i];
                content.appendChild(node.cloneNode(true));
                currentPageNodes.push(node.cloneNode(true));

                // æ£€æŸ¥æ˜¯å¦æº¢å‡º
                if (content.scrollHeight > availableHeight) {
                    content.removeChild(content.lastChild);
                    currentPageNodes.pop();

                    if (currentPageNodes.length > 0) {
                        savePage();
                        i--; 
                        continue;
                    }

                    // é•¿æ®µè½æ‹†åˆ†é€»è¾‘
                    const text = node.innerText;
                    const tagName = node.tagName;
                    let low = 0, high = text.length;
                    let bestSplitIndex = 0;
                    
                    while (low <= high) {
                        let mid = Math.floor((low + high) / 2);
                        let testNode = document.createElement(tagName);
                        testNode.innerText = text.substring(0, mid);
                        if(node.className) testNode.className = node.className;
                        
                        content.appendChild(testNode);
                        if (content.scrollHeight <= availableHeight) {
                            bestSplitIndex = mid;
                            low = mid + 1;
                        } else {
                            high = mid - 1;
                        }
                        content.removeChild(testNode);
                    }

                    if (bestSplitIndex > 0) {
                        let part1 = document.createElement(tagName);
                        part1.innerText = text.substring(0, bestSplitIndex);
                        if(node.className) part1.className = node.className;
                        currentPageNodes.push(part1);
                        savePage();

                        let part2 = document.createElement(tagName);
                        part2.innerText = text.substring(bestSplitIndex);
                        if(node.className) part2.className = node.className;
                        nodes.splice(i + 1, 0, part2);
                    } else {
                        currentPageNodes.push(node.cloneNode(true));
                        savePage();
                    }
                }
            }

            if (currentPageNodes.length > 0) {
                savePage();
            }

            // 2. æ¢å¤ CSS æ ·å¼
            content.style.height = originalHeight;
            content.style.paddingBottom = originalPadding;

            isPaginating = false;
            showLoading(false);

            const progress = settings.readingProgress[currentBookUrl];
            let pageToShow = 0;
            if (progress && progress.type === 'txt' && progress.layout === 'paginate') {
                pageToShow = progress.pos || 0;
            }
            displayTxtPage(pageToShow);
        }
        // === ä¿®æ”¹ç»“æŸ ===

        let isAnimating = false; // é˜²æ­¢ç‹‚ç‚¹æŒ‰é’®å¯¼è‡´åŠ¨ç”»é”™ä¹±

        function displayTxtPage(pageIndex, direction = 'none') {
            if (pageIndex < 0 || pageIndex >= txtPages.length) return;
            if (isAnimating) return; // å¦‚æœæ­£åœ¨ç¿»é¡µï¼Œå¿½ç•¥ç‚¹å‡»

            // å¦‚æœä¸æ˜¯ç¿»é¡µæ¨¡å¼ï¼Œæˆ–è€…æ²¡æœ‰æ–¹å‘ï¼ˆæ¯”å¦‚é€šè¿‡ç›®å½•è·³è½¬ï¼‰ï¼Œç›´æ¥æ˜¾ç¤º
            if (settings.layout !== 'paginate' || direction === 'none') {
                currentTxtPageIndex = pageIndex;
                txtContent.innerHTML = txtPages[currentTxtPageIndex];
                updateTxtProgress();
                return;
            }

            isAnimating = true;
            const content = $('#txt-content');

            // 1. æ ¹æ®æ–¹å‘è®¾ç½®æ—‹è½¬è½´ï¼ˆå·¦ç¿»è¿˜æ˜¯å³ç¿»ï¼‰
            if (direction === 'next') {
                content.style.transformOrigin = 'left center';
                content.className = 'anim-next-out'; // æ’­æ”¾â€œç¿»å‡ºå»â€åŠ¨ç”»
            } else {
                content.style.transformOrigin = 'right center';
                content.className = 'anim-prev-out';
            }

            // 2. åŠ¨ç”»æ’­æ”¾ä¸€åŠï¼ˆ400msï¼‰åï¼Œåˆ‡æ¢æ–‡å­—å†…å®¹ï¼Œç„¶åæ’­æ”¾â€œç¿»è¿›æ¥â€
            setTimeout(() => {
                currentTxtPageIndex = pageIndex;
                txtContent.innerHTML = txtPages[currentTxtPageIndex];
                updateTxtProgress();

                if (direction === 'next') {
                    content.className = 'anim-next-in';
                } else {
                    content.className = 'anim-prev-in';
                }

                // 3. åŠ¨ç”»å½»åº•ç»“æŸåï¼Œæ¸…ç† class
                setTimeout(() => {
                    content.className = '';
                    isAnimating = false;
                }, 400); // å¯¹åº” CSS ä¸­çš„ duration

            }, 400); // å¯¹åº” CSS ä¸­çš„ duration
        }
        // === ä¿®æ”¹ç»“æŸ ===
        async function processEpubContent(arrayBuffer) { currentBookType = 'epub'; applyAllSettings(); book = ePub(arrayBuffer); rendition = book.renderTo("epub-content", { width: "100%", height: "100%", flow: settings.layout === 'scroll' ? 'scrolled-doc' : 'paginated' }); rendition.on("displayed", () => applyFontSettings()); rendition.on("relocated", (location) => { currentLocation = location; updateEpubProgress(); updateActiveTocItem(); }); await book.ready; await book.locations.generate(1650); await rendition.display(); generateEpubToc(); loadLastPosition(); }
        function highlightTxtSearch(query) { const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi'); const chapterRegex = /^\s*(ç¬¬[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒä¸‡é›¶\d\s]+[ç« èŠ‚å›éƒ¨å·])(.*)$/gm; const escapedText = searcher.originalTxtContent.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); let highlightedText = escapedText.replace(regex, `<mark>$1</mark>`); let chapterIndex = 0; highlightedText = highlightedText.replace(chapterRegex, (full, title, rest) => `<span class="chapter-title" id="toc-ch-${chapterIndex++}">${(title + rest).trim()}</span>`); txtContent.innerHTML = highlightedText; }
        function clearSearch() { if (currentBookType === 'txt') { generateTxtTocAndContent(searcher.originalTxtContent); } else if (rendition) { rendition.annotations.remove(); } searcher = { results: [], currentIndex: -1, originalTxtContent: searcher.originalTxtContent }; updateSearchUI(); }
        function navigateToMatch(index) { if (index < 0 || index >= searcher.results.length) return; searcher.currentIndex = index; if (currentBookType === 'txt') { $$('mark')[index]?.scrollIntoView({ behavior: 'smooth', block: 'center' }); } else if (rendition) { rendition.display(searcher.results[index].cfi); } updateSearchUI(); }
        const updateSearchUI = () => $('#search-results-count').textContent = `${searcher.currentIndex + 1} / ${searcher.results.length}`;
        function renderLibrary() { const list = $('#library-list'); list.innerHTML = ''; for (const category in settings.books) { if (settings.books[category] && settings.books[category].length > 0) { list.innerHTML += `<li class="category-title" style="font-weight:bold; margin-top:10px;">${category}</li>`; settings.books[category].forEach(book => { list.innerHTML += `<li class="book-item"><span class="book-item-info" data-url="${book.url}">${book.name}</span><div class="book-item-actions"><button class="edit-book-btn" data-url="${book.url}" title="ç¼–è¾‘">âœï¸</button><button class="delete-book-btn" data-url="${book.url}" title="åˆ é™¤">âœ–</button></div></li>`; }); } } }
        function addBookToLibrary(name, url, category = 'æœªåˆ†ç±»') { if (!settings.books[category]) settings.books[category] = []; if (!Object.values(settings.books).flat().some(b => b.url === url)) { settings.books[category].push({ name, url }); saveSettings(); renderLibrary(); } }
        async function deleteBookFromLibrary(url) { if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æœ¬ä¹¦å—ï¼Ÿ(è¿›åº¦å’Œä¹¦ç­¾ä¹Ÿä¼šè¢«åˆ é™¤)')) return; if (url.startsWith('local-')) { await deleteBookFromDB(url); } for (const cat in settings.books) { settings.books[cat] = settings.books[cat].filter(b => b.url !== url); } delete settings.readingProgress[url]; delete settings.bookmarks[url]; saveSettings(); renderLibrary(); }
        function generateTxtTocAndContent(text) { 
            // === æ–°å¢ï¼šåº”ç”¨å‡€åŒ–è§„åˆ™ ===
            if (settings.replacements && settings.replacements.length > 0) {
                console.log("æ­£åœ¨æ‰§è¡Œå†…å®¹å‡€åŒ–...");
                settings.replacements.forEach(rule => {
                    // å…¨å±€æ›¿æ¢ï¼Œå°†ç›®æ ‡æ–‡å­—æ›¿æ¢ä¸ºç©ºå­—ç¬¦ä¸²
                    // ä½¿ç”¨ split+join æ˜¯æœ€ç®€å•ä¸”ä¸å®¹æ˜“å‡ºé”™çš„å…¨å±€æ›¿æ¢æ–¹æ³•
                    text = text.split(rule).join('');
                });
            }
            // === æ–°å¢ç»“æŸ ===

            const chapterRegex = /^\s*(ç¬¬[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒä¸‡é›¶\d\s]+[ç« èŠ‚å›éƒ¨å·])(.*)$/; 
            searcher.originalTxtContent = text; 
            const lines = text.replace(/\r/g, '').split('\n'); 
            let chapterIndex = 0; 
            let finalHtml = ''; 
            txtChapterAnchors = []; 
            
            for (const line of lines) { 
                const trimmedLine = line.trim(); 
                if (chapterRegex.test(trimmedLine)) { 
                    const anchorId = `toc-ch-${chapterIndex++}`; 
                    finalHtml += `<span class="chapter-title" id="${anchorId}">${trimmedLine}</span>`; 
                    txtChapterAnchors.push({ id: `#${anchorId}`, text: trimmedLine, index: chapterIndex - 1 }); 
                } else if (trimmedLine.length > 0) { 
                    let paragraph = trimmedLine; 
                    if (!paragraph.startsWith('ã€€ã€€')) { paragraph = 'ã€€ã€€' + paragraph; } 
                    finalHtml += `<p>${paragraph}</p>`; 
                } 
            } 
            fullTxtHtml = finalHtml; 
            if (txtChapterAnchors.length > 0) { 
                $('#toc-list').innerHTML = txtChapterAnchors.map(t => `<li data-index="${t.index}"><a href="${t.id}">${t.text}</a></li>`).join(''); 
            } else { 
                $('#toc-list').innerHTML = '<li>æœªæ£€æµ‹åˆ°ç« èŠ‚ã€‚</li>'; 
            } 
        }
        function generateEpubToc() { book.loaded.navigation.then(nav => { $('#toc-list').innerHTML = nav.toc.map((item, i) => `<li data-index="${i}"><a href="${item.href}">${item.label.trim()}</a></li>`).join(''); }); }
        function updateActiveTocItem() { $$('#toc-list li').forEach(li => li.classList.remove('active-toc-item')); if (currentBookType === 'epub' && book && book.navigation && book.navigation.toc) { if (!currentLocation) return; const currentSpineItem = book.spine.get(currentLocation.start.href); if (!currentSpineItem) return; let bestMatchIndex = -1; for (let i = 0; i < book.navigation.toc.length; i++) { const tocSpineItem = book.spine.get(book.navigation.toc[i].href); if (tocSpineItem && tocSpineItem.index <= currentSpineItem.index) { bestMatchIndex = i; } else if (tocSpineItem && tocSpineItem.index > currentSpineItem.index) { break; } } currentEpubChapterIndex = bestMatchIndex; if(currentEpubChapterIndex > -1) { $(`#toc-list li[data-index="${currentEpubChapterIndex}"]`)?.classList.add('active-toc-item'); } } else if (currentBookType === 'txt' && txtChapterAnchors.length > 0) { const currentScroll = txtContentWrapper.scrollTop; let activeIndex = -1; for (let i = txtChapterAnchors.length - 1; i >= 0; i--) { if (txtChapterAnchors[i].offsetTop <= currentScroll + txtContentWrapper.clientHeight / 2) { activeIndex = i; break; } } if (activeIndex > -1) { $(`#toc-list li[data-index="${activeIndex}"]`)?.classList.add('active-toc-item'); } } }
        function navigateChapter(direction) { if (currentBookType === 'epub' && book && rendition) { const toc = book.navigation.toc; if (!toc || toc.length === 0 || currentEpubChapterIndex === -1) return; const targetIndex = currentEpubChapterIndex + direction; if (targetIndex >= 0 && targetIndex < toc.length) { rendition.display(toc[targetIndex].href); } } else if (currentBookType === 'txt' && txtChapterAnchors.length > 0 && settings.layout === 'scroll') { const currentScroll = txtContentWrapper.scrollTop; let targetAnchorEl = null; if (direction > 0) { targetAnchorEl = Array.from($$('.chapter-title')).find(el => el.offsetTop > currentScroll + 5); } else { const prevAnchors = Array.from($$('.chapter-title')).filter(el => el.offsetTop < currentScroll - 5); targetAnchorEl = prevAnchors.length > 0 ? prevAnchors[prevAnchors.length - 1] : null; } if (targetAnchorEl) { targetAnchorEl.scrollIntoView({ behavior: 'smooth' }); } } }
        function startProgressSaving() { if (saveInterval) clearInterval(saveInterval); saveInterval = setInterval(saveCurrentPosition, 5000); }
        function saveCurrentPosition() { if (!currentBookUrl) return; let position = {}; if (currentBookType === 'txt') { const pos = settings.layout === 'scroll' ? txtContentWrapper.scrollTop : currentTxtPageIndex; position = { type: 'txt', layout: settings.layout, pos: pos }; } else if (currentBookType === 'epub' && currentLocation) { position = { type: 'epub', cfi: currentLocation.start.cfi }; } if (position.type) { settings.readingProgress[currentBookUrl] = position; saveSettings(); } }
        function loadLastPosition() { const progress = settings.readingProgress[currentBookUrl]; if (!progress) return; setTimeout(() => { if (progress.type === 'txt' && progress.layout === settings.layout) { if (settings.layout === 'scroll') { txtContentWrapper.scrollTop = progress.pos; } } else if (progress.type === 'epub' && rendition) { rendition.display(progress.cfi); } }, 100); }
        function renderBookmarks() { const list = $('#bookmarks-list'); list.innerHTML = ''; if (currentBookUrl && settings.bookmarks[currentBookUrl]) { settings.bookmarks[currentBookUrl].forEach((bookmark, index) => { list.innerHTML += `<li class="bookmark-item"><a href="#" data-index="${index}">${bookmark.name}</a><button class="delete-bookmark-btn" data-index="${index}">âœ–</button></li>`; }); } }
        function addBookmark() { if (!currentBookUrl) return alert('è¯·å…ˆæ‰“å¼€ä¸€æœ¬ä¹¦ï¼'); let location, name; if (currentBookType === 'txt') { const pos = settings.layout === 'scroll' ? txtContentWrapper.scrollTop : currentTxtPageIndex; location = { type: 'txt', layout: settings.layout, pos: pos }; const textSample = txtContent.innerText.substring(0, 30).trim(); name = textSample ? textSample + "..." : new Date().toLocaleString(); } else if (currentBookType === 'epub' && currentLocation) { location = { type: 'epub', cfi: currentLocation.start.cfi }; book.getRange(currentLocation.start.cfi).then(range => { const textSample = range.toString().trim().substring(0, 30); name = textSample ? textSample + "..." : new Date().toLocaleString(); promptAndSaveBookmark(name, location); }); return; } else { return; } promptAndSaveBookmark(name, location); }
        function promptAndSaveBookmark(defaultName, location) { const bookmarkName = prompt("è¾“å…¥ä¹¦ç­¾åç§°ï¼š", defaultName); if (!bookmarkName) return; if (!settings.bookmarks[currentBookUrl]) settings.bookmarks[currentBookUrl] = []; settings.bookmarks[currentBookUrl].push({ name: bookmarkName, location }); saveSettings(); renderBookmarks(); }
        function goToBookmark(index) { const bookmark = settings.bookmarks[currentBookUrl]?.[index]; if (!bookmark) return; const { type, layout, pos, cfi } = bookmark.location; if (type === 'txt' && layout === settings.layout) { if(layout === 'scroll') txtContentWrapper.scrollTop = pos; else displayTxtPage(pos); } else if (type === 'epub' && rendition) { rendition.display(cfi); } $('.panel.open')?.classList.remove('open'); }
        async function deleteBookmark(index) { if (confirm("ç¡®å®šåˆ é™¤æ­¤ä¹¦ç­¾å—ï¼Ÿ")) { settings.bookmarks[currentBookUrl].splice(index, 1); saveSettings(); renderBookmarks(); } }
        function updateProgress(percentage) { progressPercent.textContent = `${percentage}%`; progressSlider.value = percentage; }
        function updateTxtProgress() { let p = 0; if (settings.layout === 'scroll') { const { scrollTop, scrollHeight, clientHeight } = txtContentWrapper; p = scrollHeight > clientHeight ? Math.round((scrollTop / (scrollHeight - clientHeight)) * 100) : 100; } else { p = txtPages.length > 1 ? Math.round((currentTxtPageIndex / (txtPages.length - 1)) * 100) : 100; } updateProgress(isNaN(p) ? 0 : p); updateActiveTocItem(); }
        function updateEpubProgress() { if (!book || !book.locations || !currentLocation || !book.locations.ready) return; updateProgress(Math.round(book.locations.percentageFromCfi(currentLocation.start.cfi) * 100)); }
        function onProgressSliderChange() { const p = parseInt(progressSlider.value, 10); if (currentBookType === 'txt') { if (settings.layout === 'scroll') { txtContentWrapper.scrollTop = (txtContentWrapper.scrollHeight - txtContentWrapper.clientHeight) * (p / 100); } else { const targetPage = Math.round((p / 100) * (txtPages.length - 1)); displayTxtPage(targetPage); } } else if (rendition && book && book.locations) { if (!book.locations.ready) return; rendition.display(book.locations.cfiFromPercentage(p / 100)); } }
        // === ä¿®æ”¹ï¼šç¿»é¡µæ—¶ä¼ å…¥æ–¹å‘å‚æ•° ===
        const nextPage = () => { 
            if (settings.layout === 'paginate') { 
                if (currentBookType === 'txt') { 
                    displayTxtPage(currentTxtPageIndex + 1, 'next'); 
                } else if (rendition) { 
                    rendition.next(); 
                } 
            } 
        };
        const prevPage = () => { 
            if (settings.layout === 'paginate') { 
                if (currentBookType === 'txt') { 
                    displayTxtPage(currentTxtPageIndex - 1, 'prev'); 
                } else if (rendition) { 
                    rendition.prev(); 
                } 
            } 
        };
        // === ä¿®æ”¹ç»“æŸ ===
        // === ä¿®æ”¹ï¼šåªä¿ç•™ç³»ç»Ÿé»˜è®¤å­—ä½“ ===
        function populateFontSelect() { 
            const defaultFonts = [ 
                { name: "ç³»ç»Ÿé»˜è®¤", value: "'-apple-system', 'sans-serif'" } 
            ]; 
            fontSelect.innerHTML = defaultFonts.map(f => `<option value="${f.value}">${f.name}</option>`).join(''); 
            settings.customFonts.forEach(f => loadAndAddFont(f.name, f.url, false)); 
        }
        // === ä¿®æ”¹ç»“æŸ ===
        function loadAndAddFont(name, url, save = true) { if (!name || !url) return alert('è¯·è¾“å…¥å­—ä½“åç§°å’ŒURL/æ–‡ä»¶ã€‚'); const styleId = `custom-font-${name.replace(/\s/g, '-')}`; if ($(`#${styleId}`)) { fontSelect.value = `'${name}'`; fontSelect.dispatchEvent(new Event('change')); return; } const style = document.createElement('style'); style.id = styleId; style.textContent = `@font-face { font-family: '${name}'; src: url('${url}'); }`; document.head.appendChild(style); const option = new Option(name, `'${name}'`); fontSelect.add(option); option.selected = true; fontSelect.dispatchEvent(new Event('change')); if(save && url.startsWith('http')) { settings.customFonts.push({ name, url }); saveSettings(); } }
        function populateBgSelect() { bgSelect.innerHTML = '<option value="default">é»˜è®¤ä¸»é¢˜èƒŒæ™¯</option>'; settings.customBgs.forEach(bg => bgSelect.add(new Option(bg.name, bg.name))); }
        function addCustomBg(name, url, save = true) { if(!name || !url) return; if(settings.customBgs.some(b => b.name === name)) return alert('è¯¥åç§°çš„èƒŒæ™¯å·²å­˜åœ¨ã€‚'); settings.customBgs.push({name, url, active: false}); if(save) saveSettings(); populateBgSelect(); bgSelect.value = name; bgSelect.dispatchEvent(new Event('change')); }
        function applyBackgroundImage(url) { if (url) { body.style.backgroundImage = `url("${url}")`; body.classList.add('has-custom-bg'); } else { body.style.backgroundImage = 'none'; body.classList.remove('has-custom-bg'); } }
        document.addEventListener('click', e => { const target = e.target; const panelToggle = target.closest('.panel-toggle'); if (panelToggle) { const panel = $(`#${panelToggle.id.replace('-toggle', '-panel')}`); const isOpen = panel.classList.contains('open'); $$('.panel.open').forEach(p => p.classList.remove('open')); if (!isOpen) panel.classList.toggle('open'); return; } if (!target.closest('.panel')) $$('.panel.open').forEach(p => p.classList.remove('open')); const tocLink = target.closest('#toc-list a'); if(tocLink) { $('.panel.open')?.classList.remove('open'); const href = tocLink.getAttribute('href'); if (currentBookType === 'txt' && href.startsWith('#')) { e.preventDefault(); const chapterId = href.substring(1); if (settings.layout === 'scroll') { $(href)?.scrollIntoView({ behavior: 'smooth' }); } else { const tempDiv = document.createElement('div'); tempDiv.innerHTML = fullTxtHtml; const targetNode = tempDiv.querySelector(`#${chapterId}`); if (targetNode) { let charCount = 0; for (const child of tempDiv.childNodes) { if (child === targetNode) break; charCount += child.textContent.length; } let pageIndex = 0; let accumulatedChars = 0; for (let i = 0; i < txtPages.length; i++) { if (accumulatedChars >= charCount) { pageIndex = i; break; } accumulatedChars += txtPages[i].replace(/<[^>]+>/g, '').length; } displayTxtPage(pageIndex); } } } else if (currentBookType === 'epub') { e.preventDefault(); rendition.display(href); } return; } const bookInfo = target.closest('.book-item-info'); if (bookInfo) { e.preventDefault(); const bookData = Object.values(settings.books).flat().find(b => b.url === bookInfo.dataset.url); if(bookData) loadBook(bookData.url, bookData.name); $('.panel.open')?.classList.remove('open'); return; } if(target.closest('.delete-book-btn')) deleteBookFromLibrary(target.closest('.delete-book-btn').dataset.url); if(target.closest('.edit-book-btn')) { const url = target.closest('.edit-book-btn').dataset.url; let book, currentCategory; for (const cat in settings.books) { book = settings.books[cat].find(b => b.url === url); if(book) { currentCategory = cat; break; } } if (book) { $('#modal-overlay').style.display = 'flex'; $('#edit-book-url').value = book.url; $('#edit-book-name').value = book.name; $('#edit-book-category').value = currentCategory; } } const bookmarkLink = target.closest('#bookmarks-list a'); if (bookmarkLink) { e.preventDefault(); goToBookmark(parseInt(bookmarkLink.dataset.index)); } if (target.closest('.delete-bookmark-btn')) deleteBookmark(parseInt(target.closest('.delete-bookmark-btn').dataset.index)); });
        $('#save-edit-book-btn').addEventListener('click', () => { const url = $('#edit-book-url').value; const newName = $('#edit-book-name').value.trim(); const newCategory = $('#edit-book-category').value.trim() || 'æœªåˆ†ç±»'; if(!newName) return alert('ä¹¦åä¸èƒ½ä¸ºç©º'); let bookData; for (const cat in settings.books) { const bookIndex = settings.books[cat].findIndex(b => b.url === url); if (bookIndex !== -1) { bookData = settings.books[cat][bookIndex]; settings.books[cat].splice(bookIndex, 1); if (settings.books[cat].length === 0) delete settings.books[cat]; break; } } if (bookData) { bookData.name = newName; if (!settings.books[newCategory]) settings.books[newCategory] = []; settings.books[newCategory].push(bookData); saveSettings(); renderLibrary(); $('#modal-overlay').style.display = 'none'; } });
        $('#cancel-edit-book-btn').addEventListener('click', () => $('#modal-overlay').style.display = 'none');
        $('#search-toggle').addEventListener('click', () => $('#search-bar').classList.toggle('open'));
        $('#load-url-btn').addEventListener('click', () => { const url = $('#url-input').value.trim(); if (url) { const name = prompt("ä¹¦ç±åç§°ï¼š", url.split('/').pop().split('.').slice(0,-1).join('')) || 'æœªå‘½å'; const category = prompt("åˆ†ç±»ï¼š", "æœªåˆ†ç±»"); loadBook(url, name, category); } });
        
        $('#file-input').addEventListener('change', (e) => {
            const file = e.target.files[0]; if (!file) return;
            showLoading(true, "æ­£åœ¨å¯¼å…¥å¹¶ä¿å­˜ä¹¦ç±...");
            const reader = new FileReader();
            reader.onload = async (evt) => {
                cleanupPreviousBook();
                const fileBuffer = evt.target.result;
                const bookUrl = `local-${file.name}`;
                try {
                    await saveBookToDB({ url: bookUrl, name: file.name, content: fileBuffer });
                    addBookToLibrary(file.name, bookUrl, 'æœ¬åœ°ä¹¦ç±');
                    await loadBook(bookUrl, file.name);
                } catch (error) {
                    console.error("ä¿å­˜æˆ–åŠ è½½æœ¬åœ°ä¹¦ç±å¤±è´¥:", error);
                    alert("ä¿å­˜æˆ–åŠ è½½æœ¬åœ°ä¹¦ç±å¤±è´¥ï¼Œå¯èƒ½æ˜¯å­˜å‚¨ç©ºé—´ä¸è¶³ã€‚");
                } finally {
                    showLoading(false);
                }
            };
            reader.readAsArrayBuffer(file);
        });

        $('#encoding-select').addEventListener('change', async () => { if (currentBookType === 'txt' && currentTxtFileBuffer) { showLoading(true, "åˆ‡æ¢ç¼–ç ä¸­..."); await new Promise(resolve => setTimeout(resolve, 50)); await processTxtContent(); showLoading(false); } });
        fontSelect.addEventListener('change', (e) => { settings.fontFamily = e.target.value; applyFontSettings(); saveSettings(); });
        $('#increase-font-btn').addEventListener('click', () => { settings.fontSize = Math.min(40, settings.fontSize + 1); applyFontSettings(); saveSettings(); });
        $('#decrease-font-btn').addEventListener('click', () => { settings.fontSize = Math.max(12, settings.fontSize - 1); applyFontSettings(); saveSettings(); });
        
        // === æ–°å¢ï¼šè¡Œè·å’Œè¾¹è·çš„ç›‘å¬äº‹ä»¶ ===
        $('#line-height-input').addEventListener('input', (e) => {
            settings.lineHeight = e.target.value;
            $('#line-height-val').textContent = settings.lineHeight;
            applyFontSettings();
        });
        $('#line-height-input').addEventListener('change', async () => {
            saveSettings();
            // å¦‚æœæ˜¯ TXT ç¿»é¡µæ¨¡å¼ï¼Œæ”¹å˜è¡Œè·éœ€è¦é‡æ–°æ’ç‰ˆ
            if (currentBookType === 'txt' && settings.layout === 'paginate') {
                await paginateAndDisplayTxt();
            }
        });

        $('#padding-input').addEventListener('input', (e) => {
            settings.contentPadding = e.target.value;
            $('#padding-val').textContent = settings.contentPadding;
            applyFontSettings();
        });
        $('#padding-input').addEventListener('change', async () => {
            saveSettings();
            // å¦‚æœæ˜¯ TXT ç¿»é¡µæ¨¡å¼ï¼Œæ”¹å˜è¾¹è·éœ€è¦é‡æ–°æ’ç‰ˆ
            if (currentBookType === 'txt' && settings.layout === 'paginate') {
                await paginateAndDisplayTxt();
            }
        });
        // === æ–°å¢ç»“æŸ ===

        $('#theme-buttons').addEventListener('click', (e) => { if(e.target.tagName === 'BUTTON') { settings.theme = e.target.dataset.theme; applyAllSettings(); saveSettings(); } });
        $('#layout-buttons').addEventListener('click', async (e) => { if(e.target.tagName === 'BUTTON') { settings.layout = e.target.dataset.layout; if (rendition) rendition.flow(settings.layout === 'scroll' ? 'scrolled-doc' : 'paginated'); if (currentBookType === 'txt') { if (settings.layout === 'paginate') { await paginateAndDisplayTxt(); } else { txtContent.innerHTML = fullTxtHtml; } } applyAllSettings(); saveSettings(); } });
        $('#add-font-btn').addEventListener('click', () => loadAndAddFont($('#custom-font-name').value.trim(), $('#custom-font-url').value.trim()));
        
        // === ä¿®æ”¹ï¼šå­—ä½“ä¸Šä¼ æ”¹ä¸ºå­˜å…¥ IndexedDB ===
        $('#font-file-input').addEventListener('change', e => { 
            const file = e.target.files[0]; 
            if(file) { 
                const name = file.name.split('.').slice(0, -1).join('.');
                const reader = new FileReader(); 
                reader.onload = async (evt) => {
                    try {
                        // 1. å­˜å…¥æ•°æ®åº“
                        await saveFontToDB({ name: name, content: evt.target.result });
                        // 2. åˆ›å»º Blob URL å¹¶åº”ç”¨ (save=false å› ä¸ºå·²ç»å­˜å…¥DBï¼Œä¸éœ€è¦å­˜å…¥ settings)
                        const blob = new Blob([evt.target.result]);
                        const blobUrl = URL.createObjectURL(blob);
                        loadAndAddFont(name, blobUrl, false);
                        alert(`å­—ä½“ "${name}" å·²ä¿å­˜å¹¶åº”ç”¨ï¼`);
                    } catch (err) {
                        alert("å­—ä½“ä¿å­˜å¤±è´¥: " + err);
                    }
                }; 
                // æ³¨æ„ï¼šè¿™é‡Œæ”¹æˆäº† readAsArrayBuffer
                reader.readAsArrayBuffer(file); 
            } 
        });
        // === ä¿®æ”¹ç»“æŸ ===

        $('#add-bg-url-btn').addEventListener('click', () => { const url = $('#bg-url-input').value.trim(); if(url) { const name = prompt("èƒŒæ™¯å‘½åï¼š", "èƒŒæ™¯" + (settings.customBgs.length + 1)); if (name) addCustomBg(name, url); } });
        $('#bg-file-input').addEventListener('change', e => { const file = e.target.files[0]; if(file) { const name = prompt("èƒŒæ™¯å‘½åï¼š", file.name.split('.')[0]); if(name) { const reader = new FileReader(); reader.onload = (evt) => addCustomBg(name, evt.target.result); reader.readAsDataURL(file); } } });
        bgSelect.addEventListener('change', e => { settings.customBgs.forEach(b => b.active = (b.name === e.target.value)); applyAllSettings(); saveSettings(); });
        $('#delete-bg-btn').addEventListener('click', () => { const name = bgSelect.value; if(name !== 'default' && confirm(`åˆ é™¤èƒŒæ™¯ "${name}"?`)) { settings.customBgs = settings.customBgs.filter(b => b.name !== name); saveSettings(); populateBgSelect(); bgSelect.dispatchEvent(new Event('change')); } });
        $('#search-input').addEventListener('keypress', e => { if (e.key === 'Enter') performSearch(e.target.value.trim()); });
        $('#search-next-btn').addEventListener('click', () => navigateToMatch(searcher.currentIndex + 1)); $('#search-prev-btn').addEventListener('click', () => navigateToMatch(searcher.currentIndex - 1));
        txtContentWrapper.addEventListener('scroll', updateTxtProgress);
        progressSlider.addEventListener('input', onProgressSliderChange);
        $('#prev-chapter-btn').addEventListener('click', () => navigateChapter(-1));
        $('#next-chapter-btn').addEventListener('click', () => navigateChapter(1));
        $('#prev-page-btn').addEventListener('click', prevPage);
        $('#next-page-btn').addEventListener('click', nextPage);
        $('#next-page').addEventListener('click', nextPage);
        $('#prev-page').addEventListener('click', prevPage);
        $('#add-bookmark-btn').addEventListener('click', addBookmark);
        window.addEventListener('beforeunload', saveCurrentPosition);
        document.addEventListener('keydown', (e) => { if ($('.panel.open') || $('#search-bar.open input:focus') || $('#modal-overlay').style.display === 'flex') return; if (e.key === 'ArrowRight') nextPage(); else if (e.key === 'ArrowLeft') prevPage(); });
        
        // Initialize the database then load settings
        initDB().then(async () => {
            loadSettings();
            
            // === æ–°å¢ï¼šå¯åŠ¨æ—¶ä»æ•°æ®åº“åŠ è½½å­—ä½“ ===
            try {
                const storedFonts = await getAllFontsFromDB();
                if (storedFonts && storedFonts.length > 0) {
                    storedFonts.forEach(font => {
                        // å°†äºŒè¿›åˆ¶æ•°æ®è½¬æ¢ä¸ºæµè§ˆå™¨å¯ç”¨çš„ Blob URL
                        const blob = new Blob([font.content]);
                        const blobUrl = URL.createObjectURL(blob);
                        // åŠ è½½å­—ä½“ï¼Œå‚æ•° false è¡¨ç¤ºä¸å†é‡å¤ä¿å­˜åˆ° LocalStorage
                        loadAndAddFont(font.name, blobUrl, false);
                    });
                    console.log(`å·²æ¢å¤ ${storedFonts.length} ä¸ªæœ¬åœ°å­—ä½“`);
                }
            } catch (e) {
                console.error("æ¢å¤å­—ä½“å¤±è´¥:", e);
            }
            // === æ–°å¢ç»“æŸ ===

        }).catch(error => {
            console.error(error);
            alert("æ— æ³•åˆå§‹åŒ–æœ¬åœ°æ•°æ®åº“ï¼Œæœ¬åœ°ä¹¦ç±ä¿å­˜åŠŸèƒ½å°†ä¸å¯ç”¨ã€‚");
            loadSettings();
        });
    });
    </script>
</body>
</html>
